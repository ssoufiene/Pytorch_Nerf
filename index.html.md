# Nerf_reimplementation


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

Novel View Synthesis (NVS) is the process of generating images from new
camera viewpoints based on a set of input 2D images. Historically, the
field has been dominated by geometry-based methods, such as Structure
from Motion (SfM) and Multi-View Stereo (MVS), where the reconstruction
process is explicit:

Feature matching – detect keypoints in images and match them across
views

Camera pose estimation – determine the relative positions and
orientations of the cameras

Triangulation – compute 3D point positions to produce a sparse or dense
point cloud

In recent years, radiance field methods have emerged as the
state-of-the-art. A radiance field represents how light is distributed
and interacts with a scene, allowing new views to be synthesized without
explicitly reconstructing geometry.

One influential implicit method is
[NeRF](https://arxiv.org/pdf/2003.08934). The idea is conceptually
simple: a neural network (MLP) takes a 5D coordinate – a 3D position 𝑥 x
and a 2D viewing direction 𝑑 d – and outputs a color and density:

𝑓 ( 𝑥 , 𝑑 ) → ( 𝑐 , 𝜎 ) f(x,d)→(c,σ)

## 1. From Pixels to Rays

We will begin with loading the
[dataset](https://cseweb.ucsd.edu//~viscomp/projects/LF/papers/ECCV20/nerf/tiny_nerf_data.npz).

``` python
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from torch.utils.data import Dataset, DataLoader
import torch.optim as optim
import matplotlib.pyplot as plt
from torch import optim
import plotly.graph_objects as go
```

``` python
data = np.load('tiny_nerf_data.npz')
images = data['images']
poses = data['poses']
focal = data['focal']
```

``` python
H, W = images.shape[1:3]
print(images.shape, poses.shape, focal)

testimg, testpose = images[102], poses[102]
images = images[:100,...,:3]
poses = poses[:100]

plt.imshow(testimg)
plt.show()
```

    (106, 100, 100, 3) (106, 4, 4) 138.88887889922103

![](index_files/figure-commonmark/cell-4-output-2.png)

We want to compute, for every image pixel (*i*, *j*):

- The ray origin *o*<sub>*i**j*</sub> ∈ ℝ<sup>3</sup>  
- The ray direction *d*<sub>*i**j*</sub> ∈ ℝ<sup>3</sup>

such that any 3D point along the ray can be expressed as:

*r*<sub>*i**j*</sub>(*t*) = *o*<sub>*i**j*</sub> + *t* *d*<sub>*i**j*</sub>,  *t* ≥ 0

Step 1 — Pinhole Camera Projection Model

In the camera coordinate system, a 3D point
(*X*<sub>*c*</sub>, *Y*<sub>*c*</sub>, *Z*<sub>*c*</sub>) projects onto
the image plane as:

$$
x = f \frac{X_c}{Z_c}, \quad y = f \frac{Y_c}{Z_c}
$$

where *f* is the focal length (in pixels).

Inversely, for a given pixel (*i*, *j*), the camera-space direction of
the corresponding ray is:

$$
d\_{ij}^{(c)} =
\left\[
\frac{(i - W/2)}{f},\\
-\frac{(j - H/2)}{f},\\
-1
\right\]
$$

The subtraction by *W*/2 and *H*/2 centers the image at the origin.  
The negative signs ensure that the camera looks down the −*z* axis,
following NeRF’s convention.

Step 2 — Transforming from Camera Space to World Space

Each ray direction in camera coordinates must be rotated into the world
coordinate system using the rotation matrix:

*R* = c2w\[ : 3,  : 3\]

and the camera’s origin in world space is given by:

*t* = c2w\[ : 3, 3\]

Hence:

*d*<sub>*i**j*</sub> = *R* *d*<sub>*i**j*</sub><sup>(*c*)</sup>

*o*<sub>*i**j*</sub> = *t*

``` python
def get_rays(H, W, focal, c2w):
    """
    Get ray origins and directions for all pixels in an image.

    Args:
        H (int): Image height
        W (int): Image width
        focal (float): Focal length (in pixels)
        c2w (torch.Tensor): [4, 4] camera-to-world transformation matrix

    Returns:
        rays_o: [H, W, 3] origin of each ray (camera center in world space)
        rays_d: [H, W, 3] direction of each ray (in world space)
    """
    device = c2w.device

    # Create pixel coordinate grid
    i, j = torch.meshgrid(
        torch.arange(W, dtype=torch.float32, device=device),
        torch.arange(H, dtype=torch.float32, device=device),
        indexing='xy'
    )

    # Convert pixel coordinates to camera space directions
    dirs = torch.stack([
        (i - W * 0.5) / focal,
        -(j - H * 0.5) / focal,
        -torch.ones_like(i)
    ], dim=-1)  # [H, W, 3]

    # Rotate directions from camera space to world space
    rays_d = torch.sum(dirs[..., None, :] * c2w[:3, :3], dim=-1)  # [H, W, 3]

    # Every ray originates from the same camera center
    rays_o = c2w[:3, -1].expand(rays_d.shape)  # [H, W, 3]
    return rays_o, rays_d
```

## 2. Volume Rendering

### 2.1. Ray Parameterization

Volume rendering is a technique used to compute the color of any camera
ray:

**r**(*t*) = **o** + *t***d**,  *t* ∈ \[*t*<sub>*n*</sub>, *t*<sub>*f*</sub>\]

where **o** represents the camera position, **d** is the viewing
direction, and *t*<sub>*n*</sub> and *t*<sub>*f*</sub> denote the near
and far bounds of the ray.  
As the ray travels through the scene, it accumulates light contributions
from all the points it intersects.

### 2.2. Light Absorption and Emission

For a differential segment of length *d**t* at depth *t*, the
probability that the ray interacts with particles in that segment is
proportional to the local volume density:

*P*(interaction at *t*) = *σ*(*t*) *d**t*

To derive the **transmittance** *T*(*t*):

*T*(*t* + *d**t*) = *T*(*t*) ⋅ (1 − *σ*(*t*)*d**t*)

*T*(*t* + *d**t*) − *T*(*t*) = −*T*(*t*)*σ*(*t*)*d**t*

$$
\frac{dT(t)}{dt} = -\sigma(t) T(t)
$$

*T*(*t*) = exp ( − ∫<sub>*t*<sub>0</sub></sub><sup>*t*</sup>*σ*(*s*) *d**s*)

### 2.3. Continuous Volume Rendering Equation

By weighting the emitted color *c*(*t*) by this probability (learned by
the nn), the expected color observed along the ray can be expressed as:

*C*(**r**) = ∫<sub>*t*<sub>*n*</sub></sub><sup>*t*<sub>*f*</sub></sup>*T*(*t*) *σ*(*t*) *c*(*t*) *d**t*

This integral computes the accumulated radiance from all points along
the ray, attenuated by the transmittance of the medium.

### 2.4. Discrete Approximation

In practice, this continuous integral cannot be solved analytically and
is approximated numerically using a quadrature method. NeRF modifies
this approach by using stratified sampling: the interval
\[*t*<sub>*n*</sub>, *t*<sub>*f*</sub>\] is divided into *N* evenly
spaced bins, and one sample is drawn uniformly at random from each bin.
This stochastic sampling helps to better represent a continuous scene.

$$
t_i \sim \mathcal{U}\Bigg\[t_n + \frac{i-1}{N}(t_f - t_n), \\ t_n + \frac{i}{N}(t_f - t_n)\Bigg\]
$$

Assuming the density is constant over each small interval
*δ*<sub>*i*</sub> = *t*<sub>*i* + 1</sub> − *t*<sub>*i*</sub>, the
discrete form becomes:

$$
C(\mathbf{r}) \approx \sum\_{i=1}^{N} T_i \\ \alpha_i \\ c_i
$$

*α*<sub>*i*</sub> = 1 − exp (−*σ*<sub>*i*</sub> *δ*<sub>*i*</sub>)

$$
T_i = \prod\_{j=1}^{i-1} (1 - \alpha_j)
$$

$$
C(\mathbf{r}) = \sum\_{i=1}^{N} w_i \\ c_i, \quad \text{with } w_i = T_i \\ (1 - e^{-\sigma_i \delta_i})
$$

Here, *α*<sub>*i*</sub> represents the **opacity** of the *i*-th sample,
while *T*<sub>*i*</sub> is the **accumulated transmittance**.  
The weighted sum computes the final color along the ray and allows
gradients to propagate smoothly through the sampling process for
end-to-end optimization.

``` python
from dataclasses import dataclass

class RayBundle:
    def __init__(self, origins, directions, nears, fars):
        self.origins = origins
        self.directions = directions
        self.nears = nears
        self.fars = fars

    def __len__(self):
        return self.origins.shape[0]

    def stratified_sample(self, num_samples=64, perturb=True):
        num_rays = len(self)
        device = self.origins.device
        bins = torch.linspace(0.0, 1.0, num_samples + 1, device=device)[None, :]
        bins = self.nears + (self.fars - self.nears) * bins
        t_start, t_end = bins[:, :-1], bins[:, 1:]
        if perturb:
            u = torch.rand(num_rays, num_samples, device=device)
            t_samples = t_start + (t_end - t_start) * u
        else:
            t_samples = 0.5 * (t_start + t_end)
        return RaySamples(self, t_samples)

class RaySamples:
    def __init__(self, ray_bundle, t_samples):
        self.ray_bundle = ray_bundle
        self.t_samples = t_samples

    def compute_sample_coordinates(self):
        return self.ray_bundle.origins[:, None, :] + self.t_samples[:, :, None] * self.ray_bundle.directions[:, None, :]

    def compute_deltas(self):
        deltas = self.t_samples[:, 1:] - self.t_samples[:, :-1]
        last_delta = torch.full_like(deltas[:, :1], 1.0)
        return torch.cat([deltas, last_delta], dim=-1)

def volume_render(sigmas, rgbs, deltas):
    sigmas = sigmas.squeeze(-1)
    alphas = 1.0 - torch.exp(-sigmas * deltas)
    T = torch.cumprod(torch.cat([torch.ones_like(alphas[:, :1]), 1.0 - alphas[:, :-1] + 1e-10], dim=-1), dim=-1)
    weights = alphas * T
    final_rgb = (weights[..., None] * rgbs).sum(dim=-2)
    acc_opacity = weights.sum(dim=-1, keepdim=True)
    return final_rgb, weights, acc_opacity
```

## 3.Model Architecture

The authors wanted the model to be multi-view consistent, so they
predict the color density σ based only on the 3D position x, while
predicting the RGB color c as a function of both position x and viewing
direction d. 

All hidden layers are followed by ReLU activations, and a Sigmoid
activation is applied at the output to obtain the RGB values.

<figure>
<img
src="data:image/png;base64,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"
alt="nerf_arch.png" />
<figcaption aria-hidden="true">nerf_arch.png</figcaption>
</figure>

``` python
class nerf_mlp(nn.Module):
    def __init__(self, input_dim=63, dir_dim=27, skips=[4]):
        super().__init__()
        self.skips = skips
        self.layers = nn.ModuleList()
        in_dim = input_dim
        for i in range(8):
            if i in skips:
                in_dim += input_dim
            self.layers.append(nn.Linear(in_dim, 256))
            in_dim = 256
        self.sigma_layer = nn.Linear(256, 1)
        self.feature_layer = nn.Linear(256, 256)
        self.rgb_layers = nn.Sequential(
            nn.Linear(256 + dir_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 3)
        )

    def forward(self, x, d):
        h = x
        for i, layer in enumerate(self.layers):
            if i in self.skips:
                h = torch.cat([h, x], dim=-1)
            h = F.relu(layer(h))
        sigma = self.sigma_layer(h)
        features = self.feature_layer(h)
        rgb = torch.sigmoid(self.rgb_layers(torch.cat([features, d], dim=-1)))
        return sigma, rgb
```

## 4. Positional Encoding

Feeding the raw input coordinates (x, y, z, θ, φ) directly into a
network results in poor-quality rendering. This happens because deep
networks are biased towards learning lower frequencies, as explained in
[Rahaman et al.,
2019](https://proceedings.mlr.press/v97/rahaman19a.html).

To address this, the NeRF authors map the input to a higher-dimensional
space using positional encoding (Fourier features) before feeding it
into the MLP. This significantly improves the rendering quality.

To demonstrate this, the authors suggest training an MLP for color
prediction using different input mappings, showing the benefits of
Fourier features. Below is an implementation based on their
[paper](https://bmild.github.io/fourfeat/index.html) adapted from the
original JAX code. \### 4.1.Preprocessing

``` python
img=plt.imread("kitty.jpeg")
plt.imshow(img)
```

![](index_files/figure-commonmark/cell-8-output-1.png)

``` python
h, w, _ = img.shape

colors = img.reshape(-1, 3).astype(np.float32)
if colors.max() > 1.0:
    colors /= 255.0

y_coords = np.linspace(0, 1, h)
x_coords = np.linspace(0, 1, w)
y_grid, x_grid = np.meshgrid(y_coords, x_coords, indexing='ij')
coords_norm = np.stack([x_grid, y_grid], axis=-1)

print("coords shape:", coords_norm.reshape(-1, 2).shape)
print("colors shape:", colors.shape)

# Training data: downsample by 2
train_coords = coords_norm[::2, ::2].reshape(-1, 2)
train_colors = colors.reshape(h, w, 3)[::2, ::2].reshape(-1, 3)

# Test data: full resolution
test_coords = coords_norm.reshape(-1, 2)
test_colors = colors
train_coords = train_coords.astype(np.float32)
test_coords  = test_coords.astype(np.float32)

print("train_coords shape:", train_coords.shape)
print("test_coords shape:", test_coords.shape)

#
idx = np.random.choice(len(train_coords), 200, replace=False)
plt.figure(figsize=(5,5))
plt.scatter(train_coords[idx,0], train_coords[idx,1], c=train_colors[idx], s=5)
plt.gca().invert_yaxis()
plt.title("Sample of Training Coordinates (colored by pixel value)")
plt.show()
```

    coords shape: (261500, 2)
    colors shape: (261500, 3)
    train_coords shape: (65500, 2)
    test_coords shape: (261500, 2)

![](index_files/figure-commonmark/cell-9-output-2.png)

### 4.2. Input Mapping

- No mapping:  
  x = \[x, y\] ∈ R²

- Basic Fourier mapping:  
  phi_basic(x) = \[sin(x1), sin(x2), cos(x1), cos(x2)\] ∈ R⁴  
  Each 2D coordinate is expanded to 4 features.

- Gaussian Fourier Features:  
  phi(x) = \[sin(2π B x), cos(2π B x)\] ∈ R^(2 \* mapping_size)  
  Here, B ∈ R^(mapping_size × 2) is a Gaussian random matrix.  
  Each 2D coordinate is projected onto 256 random directions and
  expanded via sine and cosine functions, resulting in a 512-dimensional
  vector.

``` python
def input_mapping(x, B):
    x = x.astype(np.float32)
    if B is None:
        return x
    else:
        x_proj = (2.*np.pi*x) @ B.T
        return np.concatenate([np.sin(x_proj), np.cos(x_proj)], axis=-1)
mapping_size = 256
B_dict = {}

# Standard network - no mapping
B_dict['none'] = None

# Basic mapping
B_dict['basic'] = np.eye(2)

# Gaussian Fourier features at different scales
np.random.seed(0)
B_gauss = np.random.normal(size=(mapping_size, 2))
for scale in [1, 10, 100]:
    B_dict[f'gauss_{scale}'] = B_gauss * scale
```

``` python
class ImageCoordDataset(Dataset):
    def __init__(self, coords, colors, B=None):
        coords_mapped = input_mapping(coords, B)
        self.coords = torch.tensor(coords_mapped, dtype=torch.float32)
        self.colors = torch.tensor(colors, dtype=torch.float32)

    def __len__(self):
        return len(self.coords)

    def __getitem__(self, idx):
        return self.coords[idx], self.colors[idx]

def get_loaders(B, batch_size_train=128, batch_size_test=512):
    train_dataset = ImageCoordDataset(train_coords, train_colors, B)
    test_dataset  = ImageCoordDataset(test_coords, test_colors, B)
    train_loader = DataLoader(train_dataset, batch_size=batch_size_train, shuffle=True)
    test_loader  = DataLoader(test_dataset, batch_size=batch_size_test, shuffle=False)
    return train_loader, test_loader
```

Training Loop

``` python
def create_mlp(input_dim):
    return nn.Sequential(
        nn.Linear(input_dim, 256),
        nn.ReLU(),
        nn.Linear(256, 256),
        nn.ReLU(),
        nn.Linear(256, 256),
        nn.ReLU(),
        nn.Linear(256, 3),
        nn.Sigmoid()
    )
def train_network(B_name, B, epochs=15, lr=1e-3):
    print(f"\n=== Training with mapping: {B_name} ===")

    train_loader, test_loader = get_loaders(B)
    device = "cuda" if torch.cuda.is_available() else "cpu"

    # Determine input_dim automatically from one batch
    sample_coords = next(iter(train_loader))[0].numpy()
    input_dim = sample_coords.shape[1]

    model = create_mlp(input_dim).to(device)
    criterion = nn.MSELoss()
    optimizer = optim.Adam(model.parameters(), lr=lr)

    train_losses = []
    psnr_list = []

    for epoch in range(epochs):
        model.train()
        running_loss = 0.0
        for coords_batch, colors_batch in train_loader:
            coords_batch = coords_batch.to(device)
            colors_batch = colors_batch.to(device)

            optimizer.zero_grad()
            preds = model(coords_batch)
            loss = criterion(preds, colors_batch)
            loss.backward()
            optimizer.step()
            running_loss += loss.item() * coords_batch.size(0)

        epoch_loss = running_loss / len(train_loader.dataset)
        train_losses.append(epoch_loss)

        # PSNR evaluation
        model.eval()
        psnr_total = 0.0
        with torch.no_grad():
            for coords_batch, colors_batch in test_loader:
                coords_batch = coords_batch.to(device)
                colors_batch = colors_batch.to(device)
                preds = model(coords_batch)
                mse = torch.mean((preds - colors_batch) ** 2)
                psnr_batch = 10 * torch.log10(1.0 / mse)
                psnr_total += psnr_batch * coords_batch.size(0)
        psnr_avg = psnr_total / len(test_loader.dataset)
        psnr_list.append(psnr_avg.item())

        print(f"Epoch [{epoch+1}/{epochs}]  Train Loss: {epoch_loss:.6f}  PSNR: {psnr_avg:.2f} dB")

    return model, train_losses, psnr_list


def plot_results(model, B, B_name):
    device = "cuda" if torch.cuda.is_available() else "cpu"
    model.eval()
    with torch.no_grad():
        coords_flat = coords_norm.reshape(-1, 2)
        coords_mapped = torch.tensor(input_mapping(coords_flat, B), dtype=torch.float32).to(device)
        preds = model(coords_mapped).cpu().numpy()
    reconstructed = preds.reshape(h, w, 3)

    # Reconstructed image
    plt.figure(figsize=(5,5))
    plt.imshow(reconstructed)
    plt.title(f'Reconstructed Image - {B_name}')
    plt.axis('off')
    plt.show()
```

``` python
selected_mappings = ['none', 'basic', 'gauss_10']
models = {}

for mapping in selected_mappings:
    model, train_losses, psnr_list = train_network(mapping, B_dict[mapping], epochs=10)
    models[mapping] = model
```


    === Training with mapping: none ===
    Epoch [1/10]  Train Loss: 0.032596  PSNR: 17.95 dB
    Epoch [2/10]  Train Loss: 0.015389  PSNR: 20.06 dB
    Epoch [3/10]  Train Loss: 0.011913  PSNR: 20.21 dB
    Epoch [4/10]  Train Loss: 0.010062  PSNR: 21.42 dB
    Epoch [5/10]  Train Loss: 0.009041  PSNR: 21.06 dB
    Epoch [6/10]  Train Loss: 0.008216  PSNR: 21.49 dB
    Epoch [7/10]  Train Loss: 0.008289  PSNR: 21.93 dB
    Epoch [8/10]  Train Loss: 0.007623  PSNR: 22.23 dB
    Epoch [9/10]  Train Loss: 0.007402  PSNR: 22.29 dB
    Epoch [10/10]  Train Loss: 0.007352  PSNR: 21.19 dB

    === Training with mapping: basic ===
    Epoch [1/10]  Train Loss: 0.014623  PSNR: 21.77 dB
    Epoch [2/10]  Train Loss: 0.006850  PSNR: 22.82 dB
    Epoch [3/10]  Train Loss: 0.006015  PSNR: 23.55 dB
    Epoch [4/10]  Train Loss: 0.005619  PSNR: 23.60 dB
    Epoch [5/10]  Train Loss: 0.005375  PSNR: 23.71 dB
    Epoch [6/10]  Train Loss: 0.005032  PSNR: 24.45 dB
    Epoch [7/10]  Train Loss: 0.004883  PSNR: 24.48 dB
    Epoch [8/10]  Train Loss: 0.004752  PSNR: 23.88 dB
    Epoch [9/10]  Train Loss: 0.004575  PSNR: 25.19 dB
    Epoch [10/10]  Train Loss: 0.004274  PSNR: 24.27 dB

    === Training with mapping: gauss_10 ===
    Epoch [1/10]  Train Loss: 0.014457  PSNR: 26.27 dB
    Epoch [2/10]  Train Loss: 0.002680  PSNR: 26.79 dB
    Epoch [3/10]  Train Loss: 0.002263  PSNR: 27.43 dB
    Epoch [4/10]  Train Loss: 0.002117  PSNR: 28.03 dB
    Epoch [5/10]  Train Loss: 0.001968  PSNR: 28.09 dB
    Epoch [6/10]  Train Loss: 0.001954  PSNR: 28.23 dB
    Epoch [7/10]  Train Loss: 0.001852  PSNR: 28.49 dB
    Epoch [8/10]  Train Loss: 0.001827  PSNR: 28.55 dB
    Epoch [9/10]  Train Loss: 0.001772  PSNR: 28.70 dB
    Epoch [10/10]  Train Loss: 0.001696  PSNR: 28.91 dB

``` python
for mapping in selected_mappings:
    plot_results(models[mapping], B_dict[mapping], mapping)
```

![](index_files/figure-commonmark/cell-14-output-1.png)

![](index_files/figure-commonmark/cell-14-output-2.png)

![](index_files/figure-commonmark/cell-14-output-3.png)

# 5. Putting it all Together

``` python
ray_bundles = []
for pose in poses:
    rays_o, rays_d = get_rays(H, W, focal, torch.tensor(pose))
    origins = rays_o.reshape(-1, 3)
    directions = rays_d.reshape(-1, 3)

    num_rays = origins.shape[0]
    nears = torch.full((num_rays, 1), 2.0, device=origins.device)  
    fars  = torch.full((num_rays, 1), 6.0, device=origins.device)  

    ray_bundles.append(RayBundle(origins, directions, nears, fars))

print(f"Created {len(ray_bundles)} ray bundles, each with {len(ray_bundles[0])} rays.")

def positional_encoding(x, num_freqs=10):
    out = [x]
    for i in range(num_freqs):
        for fn in [torch.sin, torch.cos]:
            out.append(fn(2.0**i * x))
    return torch.cat(out, dim=-1)
```

``` python
device = "cuda" if torch.cuda.is_available() else "cpu"

model = nerf_mlp(input_dim=63, dir_dim=27).to(device)
optimizer = optim.Adam(model.parameters(), lr=5e-4)

# Training settings
num_epochs = 30
num_samples = 64
perturb = True
num_freqs_pos = 10
num_freqs_dir = 4
chunk = 32768  # number of points per MLP forward pass
batch_size = 2  # number of images per mini-batch

def compute_psnr(mse):
    return -10.0 * torch.log10(mse)

for epoch in range(num_epochs):
    epoch_loss = 0.0
    for i in range(0, len(ray_bundles), batch_size):
        batch_ray_bundles = ray_bundles[i:i+batch_size]
        all_origins = []
        all_directions = []
        all_targets = []

        for img_idx, ray_bundle in enumerate(batch_ray_bundles):
            all_origins.append(ray_bundle.origins)
            all_directions.append(ray_bundle.directions)
            all_targets.append(torch.tensor(images[i + img_idx], dtype=torch.float32).reshape(-1, 3))

        all_origins = torch.cat(all_origins, dim=0).to(device)
        all_directions = torch.cat(all_directions, dim=0).to(device)
        all_targets = torch.cat(all_targets, dim=0).to(device)

        nears = torch.full((all_origins.shape[0], 1), 2.0, device=device)
        fars  = torch.full((all_origins.shape[0], 1), 6.0, device=device)
        ray_bundle = RayBundle(all_origins, all_directions, nears, fars)
        ray_samples = ray_bundle.stratified_sample(num_samples=num_samples, perturb=perturb)
        coords = ray_samples.compute_sample_coordinates()

        coords_enc = positional_encoding(coords, num_freqs=num_freqs_pos).float()
        dirs_enc = positional_encoding(all_directions[:, None, :].expand_as(coords), num_freqs=num_freqs_dir).float()

        # Flatten for MLP
        coords_enc_flat = coords_enc.reshape(-1, coords_enc.shape[-1])
        dirs_enc_flat = dirs_enc.reshape(-1, dirs_enc.shape[-1])
        rgb_chunks = []
        sigma_chunks = []
        for j in range(0, coords_enc_flat.shape[0], chunk):
            coords_chunk = coords_enc_flat[j:j+chunk]
            dirs_chunk = dirs_enc_flat[j:j+chunk]
            sigma_chunk, rgb_chunk = model(coords_chunk, dirs_chunk)
            rgb_chunks.append(rgb_chunk)
            sigma_chunks.append(sigma_chunk)

        sigma = torch.cat(sigma_chunks, dim=0).view(coords.shape[0], coords.shape[1], 1)
        rgb = torch.cat(rgb_chunks, dim=0).view(coords.shape[0], coords.shape[1], 3)

        deltas = ray_samples.compute_deltas()
        rgb_map, weights, opacity = volume_render(sigma, rgb, deltas)

        # Loss & optimization
        loss = F.mse_loss(rgb_map, all_targets)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        epoch_loss += loss.item() * batch_size  # accumulate weighted by batch size

    # Average loss over the dataset
    epoch_loss /= len(ray_bundles)
    epoch_psnr = compute_psnr(torch.tensor(epoch_loss))
    print(f"Epoch {epoch+1} | Loss: {epoch_loss:.6f} | PSNR: {epoch_psnr:.2f} dB")

# ✅ Save the model weights after training
save_path = "nerf_model.pth"
torch.save(model.state_dict(), save_path)
print(f"Model saved to {save_path}")
```

    Epoch 1 | Loss: 0.053099 | PSNR: 12.75 dB
    Epoch 2 | Loss: 0.032919 | PSNR: 14.83 dB
    Epoch 3 | Loss: 0.025018 | PSNR: 16.02 dB
    Epoch 4 | Loss: 0.018219 | PSNR: 17.39 dB
    Epoch 5 | Loss: 0.014011 | PSNR: 18.54 dB
    Epoch 6 | Loss: 0.011613 | PSNR: 19.35 dB
    Epoch 7 | Loss: 0.010020 | PSNR: 19.99 dB
    Epoch 8 | Loss: 0.009211 | PSNR: 20.36 dB
    Epoch 9 | Loss: 0.008326 | PSNR: 20.80 dB
    Epoch 10 | Loss: 0.007798 | PSNR: 21.08 dB
    Epoch 11 | Loss: 0.007354 | PSNR: 21.34 dB
    Epoch 12 | Loss: 0.007032 | PSNR: 21.53 dB
    Epoch 13 | Loss: 0.006850 | PSNR: 21.64 dB
    Epoch 14 | Loss: 0.006534 | PSNR: 21.85 dB
    Epoch 15 | Loss: 0.006326 | PSNR: 21.99 dB
    Epoch 16 | Loss: 0.006137 | PSNR: 22.12 dB
    Epoch 17 | Loss: 0.005961 | PSNR: 22.25 dB
    Epoch 18 | Loss: 0.005752 | PSNR: 22.40 dB
    Epoch 19 | Loss: 0.005568 | PSNR: 22.54 dB
    Epoch 20 | Loss: 0.005384 | PSNR: 22.69 dB
    Epoch 21 | Loss: 0.005248 | PSNR: 22.80 dB
    Epoch 22 | Loss: 0.005101 | PSNR: 22.92 dB
    Epoch 23 | Loss: 0.004951 | PSNR: 23.05 dB
    Epoch 24 | Loss: 0.004953 | PSNR: 23.05 dB
    Epoch 25 | Loss: 0.004726 | PSNR: 23.26 dB
    Epoch 26 | Loss: 0.004636 | PSNR: 23.34 dB
    Epoch 27 | Loss: 0.004502 | PSNR: 23.47 dB
    Epoch 28 | Loss: 0.004376 | PSNR: 23.59 dB
    Epoch 29 | Loss: 0.004345 | PSNR: 23.62 dB
    Epoch 30 | Loss: 0.004217 | PSNR: 23.75 dB
    Model saved to nerf_model.pth

<iframe src="nerf_360.html" width="700" height="500" style="border:none;">

</iframe>
